---
title: 'P_1'
description: 'Learn how to create an API key and start building with Livepeer!'
---


# Practical_1 üò∂‚Äçüå´Ô∏è

### 1 Implement a function for each of following problems and count the number of steps executed/Time taken by each function on various inputs and write complexity of each function. Also draw a comparative chart. In each of the following function N will be passed by user.
#### 1 To calculate sum of 1 to N number using loop.
```java copy 
public static int sumUsingLoop(int N) {
    int sum = 0;
    for (int i = 1; i <= N; i++) {
        sum += i;
    }
    return sum;
}
```
#### 2 To calculate sum of 1 to N number using equation.
``` java copy
public static int sumUsingEquation(int N) {
    return (N * (N + 1)) / 2;
}
```
#### 3  To calculate sum of 1 to N numbers using recursion. in java
``` java copy
public static int sumUsingRecursion(int N) {
    if (N == 0) {
        return 0;
    }
    return N + sumUsingRecursion(N - 1);
}
```
#### A comparative chart of the time complexity for the three functions would look like this:

![compare](https://sem4.netlify.app/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftime-com-compare-1.38fb4e41.png&w=828&q=75)

### 2 Implement functions to print nth Fibonacci number using iteration and recursive method. Compare the performance of two methods by counting number of steps executed on various inputs. Also draw a comparative chart. (Fibonacci series 1, 1, 2, 3, 5, 8‚Ä¶.. Here 8 is the 6th Fibonacci number)

#### 1 Iteration Method
````java copy 
public class fibonicii {
    public static void main(String[] args) {
        int n1=0,n2=1,n3,i,count=10,count1=0;
        System.out.print(n1+" "+n2);

        for(i=2;i<count;++i) // count1++;
        {
            n3=n1+n2;
            count1++;

            n1=n2;    count1++;
            n2=n3;
            count1++;
        }
        System.out.println(" "+n3);
        System.out.println("count = "+count1);
    }
}


````
#### 2 Recursive Method 
````java copy
public static int fibonacciRecursive(int n) {
    if (n <= 0) {
        return 0;
    } else if (n == 1 || n == 2) {
        return 1;
    }
    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}
````
![copmx](https://sem4.vercel.app/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftime-com-2.500ebcee.png&w=828&q=75)


### 3 Write user defined functions for the following sorting methods and compare their performance by time measurement with random data and Sorted data.

#### 1. Selection Sort
``` java copy
public static int[] selectionSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
    return arr;
}
```
#### 2. Bubble Sort
````java copy
public static int[] bubbleSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    return arr;
}

````
#### 3. Insertion Sort
````java copy
public static int[] insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
    return arr;
}

````
#### 4. Merge Sort
```` java copy
public static int[] mergeSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    int mid = arr.length / 2;
    int[] left = Arrays.copyOfRange(arr, 0, mid);
    int[] right = Arrays.copyOfRange(arr, mid, arr.length);
    return merge(mergeSort(left), mergeSort(right));
}

private static int[] merge(int[] left, int[] right) {
    int[] result = new int[left.length + right.length];
    int i = 0;
    int j = 0;
    int k = 0;
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result[k] = left[i];
            i++;
        } else {
            result[k] = right[j];
            j++;
        }
        k++;
    }
    while (i < left.length) {
        result[k] = left[i];
        i++;
        k++;
    }
    while (j < right.length) {
        result[k] = right[j];
        j++;
        k++;
    }
    return result;
}

````
#### 5. Quick Sort
````java copy
public static void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high);
        quickSort(arr, low, pivotIndex);
        quickSort(arr, pivotIndex + 1, high);
    }
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[low];
    int i = low - 1;
    int j = high + 1;
    while (true) {
        do {
            i++;
        } while (arr[i] < pivot);
        do {
            j--;
        } while (arr[j] > pivot);
        if (i >= j) {
            return j;
        }
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
````
![comop](https://sem4.vercel.app/images/comp-3.png)

### 4 Implement a function of sequential search and count the steps executed by function on various inputs for best case and worst case. Also write complexity in each case and draw a comparative chart.
````java copy
public static int sequentialSearch(int[] arr, int target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}
````
![comp-4](https://sem4.vercel.app/images/comp-4.png)

### 5 Implement a function of binary search and count the steps executed by function on various inputs for best case and worst case. Also write complexity in each case and draw a comparative chart.
````c copy
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int count=0; 
void bubble(int a[], int n) 
{     
			int i, j, temp; 
for (i = 0; i< n; i++) 
{         
				for (j = i + 1; j < n; j++) 
		{             
					if (a[j] < a[i]) 
			{                 
						temp = a[i];                 
						a[i] = a[j];                 
						a[j] = temp; 
			} 
		} 
	} 
} 
int binarySearch(int arr[], int l, int r, int x) 
{     
			while (r >= l) 
			{         
				count++;         
				int mid = l + (r - l) / 2;         
				count++; 
		if (arr[mid] == x) 
		{ 
			count++;             
					count++;             
					return mid; 
		}         
				else if (arr[mid] > x) 
		{ 
			count++;             
					count++;             
					r=mid-1; 
		}         
				else         
				{ 
					l=mid +1;             
					count++; 
		}     
			}     
			count++;     
			return -1; 
}  
int main(void) 
{     
			clock_t start, 
			end;     
			double time_taken;     
			time_t t;     
			int n = printf("please enter the range: ");     
			scanf("%d", &n);     
			int arr[n];     
			srand((unsigned)time(&t));     
			printf("Random Data: ");     	
			for (int i = 0; i< n; i++) 
	{         
				arr[i] = rand() % 100; 
		printf("%d ", arr[i]); 
	}     
			bubble(arr,n);     
			printf("\nSorted Data: ");     
			for (int i = 0; i< n; i++) 
	{         
				printf("%d ", arr[i]); 
	}     
			int x ;
			printf("\nEnter the element you want to search: ");     
			scanf("%d",&x);     
			start=clock(); 
	int result = binarySearch(arr, 0, n - 1, x); 
	if(result == -1) 
	{         
				printf("Element is not present in array"); 
	}     
			else
			{ 
		printf("Element is present at index %d", result); 
	}     
			end=clock();     
			time_taken = ((double) (end - start)) / CLOCKS_PER_SEC;     
			printf("\ntime taken: %f ",time_taken);     
			printf("\nNumber of steps are: %d ", count); 
}


````
![comp5](https://sem4.vercel.app/images/comp5.png)

### 6 Implement program for randomized version of quick sort and compare its performance with normal version of quick sort using steps count on various number of inputs.
#### 1 randomized version for quickSort
```c copy
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int sc = 0; 
int partition(int a[], 
int start, int end) 
{     
int pivotIndex = start + rand()%(end - start+ 1);
//generates a random number as a pivot     
sc++;     
int pivot = a[end]; // pivot element     
sc++;     
int i = (start - 1);     
sc++;     
pivot = a[pivotIndex];     
sc++;     
int temp;     
sc++;     
temp = a[pivotIndex];     
sc++;     
a[pivotIndex] = a[end];     
sc++;     
a[end] = temp;     
sc++; 
	for (int j = start; j <= end - 1; j++,sc++)     
{ 
// If current element is smaller than the pivot         
if (a[j] < pivot) 
		{	
i++; // increment index of smaller element           sc++;             
int t = a[i];             
sc++;             	
a[i] = a[j];             
sc++;             
a[j] = t;             
sc++; 
		}     
} 
int t = a[i + 1];     
sc++; 
a[i + 1] = a[end];     
sc++; 
a[end] = t;     
sc++;     
return (i + 1);     
sc++; 
}  
int quick(int a[], int start, int end)/* a[] = array to be sorted, start = 
Starting index, end = Ending index */ 
{     
if (start < end) 
	{         
sc++;         
int p = partition(a, start, end); 
// p is the partitioning index         
sc++;         
quick(a, start, p - 1);         
quick(a, p + 1, end); 
	} 
}  
int main() 
{     
int n;     
clock_tstart,end;     
double time_taken;     
time_t t;     
printf("Enter no of elements in array : ");     
scanf("%d", &n);     
int a[n];     
srand((unsigned) time(&t));     
printf("Unsorted Array : \n");     
for (int i = 0; i< n; i++) 
	{  
		a[i] = rand() % 100;         
printf("%d ", a[i]); 
	} 
	start = clock();     
quick(a, 0, n - 1); 
	printf("\nSorted Array : \n");     
for (int i = 0; i< n; i++) 
	{         
printf("%d ", a[i]); 
	}     
end = clock();     
time_taken = ((double) (end - start)) / CLOCKS_PER_SEC;   printf("\nTime taken : %f", time_taken); 
	printf("\nSteps count : %d",sc); 
} 

```
![comp6](https://sem4.vercel.app/images/comp6.png)


### 7 Implement program of Counting Sort
```c copy
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int scount = 0; 
int getMax(int a[], int n) 
{     
    int max = a[0];     
scount++;     
    for (int i = 1; i< n; i++, scount++) 
    {         
        if (a[i] > max) 
        {             
            max = a[i];             
scount++; 
        }     

    }     
    return max;     
scount++; 
}  
void countSort(int a[], int n) // function to perform counting sort 
{     
    int output[n + 1];     
scount++;     
    int max = getMax(a, n);     
scount++;     
    int count[max + 1]; // create count array with size [max+1]     

scount++; 
    for (int i = 0; i<= max; ++i,scount++) 
    { 
        count[i] = 0; // Initialize count array with all zeros         
scount++; 
    }      
    for (int i = 0; i< n; i++,scount++) // Store the count of each element 
    { 
        count[a[i]]++;         
scount++; 
    }      
    for (int i = 1; i<= max; i++,scount++) 
    { 
        count[i] += count[i - 1];         
scount++; // find cumulative frequency 
    }     
    for (int i = n - 1; i>= 0; i--,scount++) 
    {         
        output[count[a[i]] - 1] = a[i];         
scount++;         
        count[a[i]]--;         
scount++; // decrease count for same numbers 
    }     
    for (int i = 0; i< n; i++,scount++) 
    {         
        a[i] = output[i];         
scount++; // store the sorted elements into main array 
    } 

} 
int main() 
{     
    int sz;     
clock_t start, end;     
    double time_taken;     
time_t t;     
printf("Enter the size of array: ");     
scanf("%d", &sz);     
    int randArray[sz], i;     
srand((unsigned)time(&t));     
    for (i = 0; i<sz; i++) 
    {         
randArray[i] = rand() % 100; 
    }     
printf("\nElements of the array: ");     
    for (i = 0; i<sz; i++) 
    {         
printf("%d ", randArray[i]); 
    }     
    start = clock();     
countSort(randArray, sz);     
printf("\nAfter sorting array elements are :");     
    for (i = 0; i<sz; i++) 
    { 
printf("%d ", randArray[i]); 
    }     
    end = clock();     
time_taken = ((double)(end - start)) / CLOCKS_PER_SEC;     
printf("\nTime taken : %f", time_taken);     
printf("\nnumber of steps taken: %d ",scount);   
}
```

### 8 Implement Program for fractional knapsack using Greedy design technique
```java copy
public static double fractionalKnapsack(int[] wt, int[] val, int capacity) {
    double maxValue = 0;
    Item[] items = new Item[wt.length];
    for (int i = 0; i < wt.length; i++) {
        items[i] = new Item(wt[i], val[i]);
    }
    Arrays.sort(items, (i1, i2) -> {
        double r1 = (double) i1.value / i1.weight;
        double r2 = (double) i2.value / i2.weight;
        return -Double.compare(r1, r2);
    });
    int currentWeight = 0;
    for (Item item : items) {
        if (currentWeight + item.weight <= capacity) {
            maxValue += item.value;
            currentWeight += item.weight;
        } else {
            int remaining = capacity - currentWeight;
            maxValue += item.value * ((double) remaining / item.weight);
            break;
        }
    }
    return maxValue;
}
```

### 9 Implement Program for ‚ÄúMaking Change‚Äù using Greedy design technique
```
public static int makeChange(int[] coins, int change) {
    int numCoins = 0;
    for (int i = coins.length - 1; i >= 0; i--) {
        while (change >= coins[i]) {
            change -= coins[i];
            numCoins++;
        }
    }
    return numCoins;
}

```
### 10 Implement Program for ‚ÄúMaking Change‚Äù using Dynamic Programming
```java copy
public static int makeChange(int[] coins, int change) {
    int[] dp = new int[change + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    for (int i = 1; i <= change; i++) {
        for (int j = 0; j < coins.length; j++) {
            if (coins[j] <= i) {
                dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
            }
        }
    }
    return dp[change];
}
```


