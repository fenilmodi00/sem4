---
title: 'P_1'
description: 'Learn how to create an API key and start building with Livepeer!'
---


# Practical_1 üò∂‚Äçüå´Ô∏è

### 1 Implement a function for each of following problems and count the number of steps executed/Time taken by each function on various inputs and write complexity of each function. Also draw a comparative chart. In each of the following function N will be passed by user.
#### 1 To calculate sum of 1 to N number using loop.
```java copy 
public static int sumUsingLoop(int N) {
    int sum = 0;
    for (int i = 1; i <= N; i++) {
        sum += i;
    }
    return sum;
}
```
#### 2 To calculate sum of 1 to N number using equation.
``` java copy
public static int sumUsingEquation(int N) {
    return (N * (N + 1)) / 2;
}
```
#### 3  To calculate sum of 1 to N numbers using recursion. in java
``` java copy
public static int sumUsingRecursion(int N) {
    if (N == 0) {
        return 0;
    }
    return N + sumUsingRecursion(N - 1);
}
```
#### A comparative chart of the time complexity for the three functions would look like this:

![compare](https://sem4.netlify.app/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftime-com-compare-1.38fb4e41.png&w=828&q=75)

### 2 Implement functions to print nth Fibonacci number using iteration and recursive method. Compare the performance of two methods by counting number of steps executed on various inputs. Also draw a comparative chart. (Fibonacci series 1, 1, 2, 3, 5, 8‚Ä¶.. Here 8 is the 6th Fibonacci number)

#### 1 Iteration Method
````java copy 
public class fibonicii {
    public static void main(String[] args) {
        int n1=0,n2=1,n3,i,count=10,count1=0;
        System.out.print(n1+" "+n2);

        for(i=2;i<count;++i) // count1++;
        {
            n3=n1+n2;
            count1++;

            n1=n2;    count1++;
            n2=n3;
            count1++;
        }
        System.out.println(" "+n3);
        System.out.println("count = "+count1);
    }
}


````
#### 2 Recursive Method 
````java copy
public static int fibonacciRecursive(int n) {
    if (n <= 0) {
        return 0;
    } else if (n == 1 || n == 2) {
        return 1;
    }
    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}
````
![copmx](https://sem4.vercel.app/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftime-com-2.500ebcee.png&w=828&q=75)


### 3 Write user defined functions for the following sorting methods and compare their performance by time measurement with random data and Sorted data.

#### 1. Selection Sort
``` java copy
public static int[] selectionSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
    return arr;
}
```
#### 2. Bubble Sort
````java copy
public static int[] bubbleSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    return arr;
}

````
#### 3. Insertion Sort
````java copy
public static int[] insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
    return arr;
}

````
#### 4. Merge Sort
```` java copy
public static int[] mergeSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    int mid = arr.length / 2;
    int[] left = Arrays.copyOfRange(arr, 0, mid);
    int[] right = Arrays.copyOfRange(arr, mid, arr.length);
    return merge(mergeSort(left), mergeSort(right));
}

private static int[] merge(int[] left, int[] right) {
    int[] result = new int[left.length + right.length];
    int i = 0;
    int j = 0;
    int k = 0;
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result[k] = left[i];
            i++;
        } else {
            result[k] = right[j];
            j++;
        }
        k++;
    }
    while (i < left.length) {
        result[k] = left[i];
        i++;
        k++;
    }
    while (j < right.length) {
        result[k] = right[j];
        j++;
        k++;
    }
    return result;
}

````
#### 5. Quick Sort
````java copy
public static void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high);
        quickSort(arr, low, pivotIndex);
        quickSort(arr, pivotIndex + 1, high);
    }
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[low];
    int i = low - 1;
    int j = high + 1;
    while (true) {
        do {
            i++;
        } while (arr[i] < pivot);
        do {
            j--;
        } while (arr[j] > pivot);
        if (i >= j) {
            return j;
        }
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
````
![comop](https://sem4.vercel.app/images/comp-3.png)

### 5 Implement a function of sequential search and count the steps executed by function on various inputs for best case and worst case. Also write complexity in each case and draw a comparative chart.
````java copy
#include <stdio.h>
#include <stdlib.h>
void countingSort(int arr[], int n) {
 int max_val = arr[0];
 for(int i = 1; i < n; i++) {
 if(arr[i] > max_val) {
 max_val = arr[i];
 }
 }
 int size = max_val + 1;
 int count[size];
 for(int i = 0; i < size; i++) {
 count[i] = 0;
 }
 for(int i = 0; i < n; i++) {
 count[arr[i]]++;
 }
 int sorted[n];
 int j = 0;
 for(int i = 0; i <= max_val; i++) {
 while(count[i] > 0) {
 sorted[j] = i;
 count[i]--;
 j++;
 }
 }
  for(int i = 0; i < n; i++) {
 arr[i] = sorted[i];
 }
}
void printArr(int arr[], int n) {
 printf("[");
 for(int i = 0; i < n; i++) {
 printf("%d ", arr[i]);
 }
 printf("]");
}
int main() {
 int size;
 printf("Rathod Yuvraj - 21012011129");
 printf("Enter the size of the array: ");
 scanf("%d", &size);
 int arr[size];
 printf("Enter %d integers:\n", size);
 for(int i = 0; i < size; i++) {
 scanf("%d", &arr[i]);
 }
 printf("Data before sorting: ");
 printArr(arr, size);
 countingSort(arr, size); 
  printf("\nData after sorting: ");
 printArr(arr, size);
 return 0;
} 

````
![comp5](https://sem4.vercel.app/images/comp5.png)

### 6 Implement program for randomized version of quick sort and compare its performance with normal version of quick sort using steps count on various number of inputs.
#### 1 randomized version for quickSort
```c copy
  #include <stdio.h>
void knapsack(int n, float weight[], float profit[], float capacity)
{
 float x[20], tp = 0;
 int i, j, k;
 k = capacity;
 for (i = 0; i < n; i++){
 x[i] = 0.0;
 }
 printf("\nthe result is:- ");
 for (i = 0; i < n; i++)
 {
 if (weight[i] > k)
 break;
 else
 {
 x[i] = 1.0;
 int p = profit[i];
 tp = tp + profit[i];
 k = k - weight[i];
 printf("%f * %d +\t ", x[i],p);
 }
 }
 if (i < n)
 x[i] = k / weight[i];
 tp = tp + (x[i] * profit[i]);
 int p = profit[i];
 printf("%f * %d\t ", x[i],p);
 printf("\nmaximum profit is: %f", tp);
}
int main()
{ 
  printf("Rathod Yuvraj - 21012011129\n");

 int num, i, j;
 float weight[20], profit[20], capacity;
 float ratio[20], temp;
 printf("\nenter the no of object:-");
 scanf("%d", &num);
 printf("\nenter the weight and profit of each object:-\n ");
 for (i = 0; i < num; i++)
 {
 printf("weight[%d] :",i+1);
 scanf("%f", &weight[i]);
 printf("profit[%d] :",i+1);
 scanf("%f", &profit[i]);
 }
 printf("\nEnter the capacityacity of knapsack:- ");
 scanf("%f", &capacity);
 for (i = 0; i < num; i++)
 {
 ratio[i] = profit[i] / weight[i];
 printf("profit / weight ratio for object %d is %f \n",i+1,ratio[i]);
 }
 for (i = 0; i < num; i++)
 {
 for (j = i + 1; j < num; j++)
 {
 if (ratio[i] < ratio[j])
 {
 temp = ratio[j];
 ratio[j] = ratio[i];
 ratio[i] = temp;
 temp = weight[j];
 weight[j] = weight[i];
 weight[i] = temp;
 temp = profit[j];
 profit[j] = profit[i];
 profit[i] = temp; 
 }
 }
 }
 knapsack(num, weight, profit, capacity);
 return (0);
}

```
![comp6](https://sem4.vercel.app/images/comp6.png)


### 7 Implement program of Counting Sort
```c copy
 #include <stdio.h>
#include <stdlib.h>
#define MAX_COINS 50
#define MAX_COST 1000
void sort(int array[], int size) {
 for (int step = 0; step < size - 1; ++step) {
 for (int i = 0; i < size - step - 1; ++i) {
 if (array[i] > array[i + 1]) {
 int temp = array[i];
 array[i] = array[i + 1];
 array[i + 1] = temp;
 }
 }
 }
}
void findMin(int coins[], int n, int cost) {
 int coinList[MAX_COINS] = { 0 };
 int i, k = 0;
 for (i = n - 1; i >= 0; i--) {
 while (cost >= coins[i]) {
 cost -= coins[i];
 coinList[k++] = coins[i];
 }
 }
printf("\nMinimum number of coins required to make the given amount: %d\n", k);
 printf("The coins used to make the amount are: ");
 for (i = 0; i < k; i++) { 
 printf("%d ", coinList[i]);
 }
 printf("\n");
 return;
}
int main() {
 int n, cost, coins[MAX_COINS];
 printf("rathod Yuvraj - 21012011129\n");
 printf("Enter the number of available type of coins : ");
 scanf("%d", &n);
 printf("Enter the value of each coin: ");
 for (int i = 0; i < n; i++) {
 scanf("%d", &coins[i]);
 }
 sort(coins,n);
printf("Enter the cost for which you want to find the minimum number of coins required: ");
 scanf("%d", &cost);
 findMin(coins, n, cost);
 return 0;
} 

```

### 8 Implement Program for fractional knapsack using Greedy design technique
```C copy
#include <stdio.h>
#include <stdlib.h>
int main()
{
 int m, n, i, j;
 printf("Rathod Yuvraj - 21012011129 \n");
 printf("Enter the amount of which you want change: ");
 scanf("%d", &m);
 printf("Enter the number of determinants: ");
 scanf("%d", &n);
 int c[n + 1][m + 1], dc[n + 1];
 printf("Enter the determinants: ");
 dc[0] = 0;
 for (i = 1; i < n + 1; i++)
 scanf("%d", &dc[i]);
 for (i = 0; i < n + 1; i++)
 {
 for (j = 0; j <= m; j++)
 c[i][j] = 0;
 }
 for (i = 0; i < n + 1; i++)
 c[i][0] = 0;
 for (i = 0; i < m + 1; i++)
 {
 c[0][i] = i;
 }
 for (i = 1; i < n + 1; i++)
 {
 for (j = 1; j < m + 1; j++)
 {
 if (dc[1] > c[0][j])
 c[i][j] = 0;
 else if (dc[i] <= j)
 {
 if ((c[i][j - dc[i]] + 1) < c[i - 1][j])
 c[i][j] = (c[i][j - dc[i]] + 1);
 else
 c[i][j] = c[i - 1][j];
 }
 else
 c[i][j] = c[i - 1][j];
 }
 }
 printf("\nThe change you get is: ");
 i = n;
 j = m;
 while (i != 1)
 {
 if (c[i][j] == c[i - 1][j])
 i = i - 1;
 else
 {
 j = j - dc[i];
 printf(" %d ", dc[i]);
 }
 } 
 printf("\n\n");
 return 0;
} 

```

### 9 Implement Program for ‚ÄúMaking Change‚Äù using Greedy design technique
```C copy
#include <stdio.h>
int max(int a, int b)
{
 return (a > b) ? a : b;
}
int knapSack(int W, int wt[], int val[], int n)
{
 int i, w;
 int K[n + 1][W + 1];
 for (i = 0; i <= n; i++)
 {
 for (w = 0; w <= W; w++)
 {
 if (i == 0 || w == 0)
 K[i][w] = 0;
 else if (wt[i - 1] <= w)
 K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]);
 else
 K[i][w] = K[i - 1][w];
 }
 }
 return K[n][W];
}
int main()
{
 int n, W;
 printf("rathod Yuvraj - 21012011129 \n");
 printf("Enter the number of items: ");
 scanf("%d", &n);
 int val[n], wt[n]; 
 printf("Enter the values of the items: ");
 for (int i = 0; i < n; i++)
 scanf("%d", &val[i]);
 printf("Enter the weights of the items: ");
 for (int i = 0; i < n; i++)
 scanf("%d", &wt[i]);
 printf("Enter the maximum capacity of the knapsack: ");
 scanf("%d", &W);
 int result = knapSack(W, wt, val, n);
 printf("The maximum profit is:%d\n", result);
 return 0;
} 

```
### 10 Implement Program for ‚ÄúMaking Change‚Äù using Dynamic Programming
```C copy
#include <stdio.h>
#include <math.h>
#include<stdlib.h>
int board[20], count;
void print(int n) {
 int i, j;
 printf("\nSolution %d:\n\n", ++count);
 for (i = 1; i <= n; ++i) {
 printf("\t%d", i);
 }
 for (i = 1; i <= n; ++i) {
 printf("\n%d", i);
 for (j = 1; j <= n; ++j) { // for nxn board
 if (board[i] == j)
 printf("\tQ"); //queen at i,j position
 else
 printf("\t-"); //empty slot 
  }
 }
}
int place(int row, int column) {
 int i;
 for (i = 1; i <= row - 1; ++i) {
 // checking column and diagonal conflicts
 if (board[i] == column)
 return 0; 
  else if (abs(board[i] - column) == abs(i - row))
 return 0;
 }
 return 1; // no conflicts
}
void queen(int row, int n) {
 int column;
 for (column = 1; column <= n; ++column) {
 if (place(row, column)) {
 board[row] = column; // no conflicts so place queen
 if (row == n) // dead end
 print(n); // printing the board configuration
 else // try queen with next position
 queen(row + 1, n);
 }
 }
}
int main() {
 int n;
 printf("Rathod Yuvraj - 21012011129\n");
 printf(" - N Queens Problem Using Backtracking -\n");
 printf("Enter number of Queens: ");
 scanf("%d", &n);
 if (n < 4) {
 printf("Solution does not exist for n < 4\n");
 return 0;
 }
 queen(1, n);
 if (count == 0) {
 printf("Solution does not exist\n"); 
  }
 return 0;
} 


```


