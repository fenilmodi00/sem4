---
title: 'P_1'
description: 'Learn how to create an API key and start building with Livepeer!'
---


# Practical_1 üò∂‚Äçüå´Ô∏è

### 1 Implement a function for each of following problems and count the number of steps executed/Time taken by each function on various inputs and write complexity of each function. Also draw a comparative chart. In each of the following function N will be passed by user.
#### 1 To calculate sum of 1 to N number using loop.
```java copy 
public static int sumUsingLoop(int N) {
    int sum = 0;
    for (int i = 1; i <= N; i++) {
        sum += i;
    }
    return sum;
}
```
#### 2 To calculate sum of 1 to N number using equation.
``` java copy
public static int sumUsingEquation(int N) {
    return (N * (N + 1)) / 2;
}
```
#### 3  To calculate sum of 1 to N numbers using recursion. in java
``` java copy
public static int sumUsingRecursion(int N) {
    if (N == 0) {
        return 0;
    }
    return N + sumUsingRecursion(N - 1);
}
```
#### A comparative chart of the time complexity for the three functions would look like this:

![compare](https://sem4.netlify.app/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftime-com-compare-1.38fb4e41.png&w=828&q=75)

### 2 Implement functions to print nth Fibonacci number using iteration and recursive method. Compare the performance of two methods by counting number of steps executed on various inputs. Also draw a comparative chart. (Fibonacci series 1, 1, 2, 3, 5, 8‚Ä¶.. Here 8 is the 6th Fibonacci number)

#### 1 Iteration Method
```` copy 
#include <stdio.h>
void loop_fibo(int);
int rec_fibo(int);
int count_loop=0;
int count_rec=0;
int main()
{
int n,m=0,i;
printf("Mehta Manthan 21012021048");
printf("Enter the value of n:");
scanf("%d",&n);
loop_fibo(n);
printf("\nCount of loop: %d\n",count_loop);
printf("%d ",rec_fibo(n));
printf("\nCount of Recursion: %d\n",count_rec);
return 0;
}
void loop_fibo(int n){
int i,first=0,second=1,result;
count_loop++;
for(i=0;i<=n;i++){
if(i<=1){
result=i;
count_loop++;
}
else{
result=first+second;
first=second;
second=result;
count_loop+=3;
}
printf("%d ",result);
}
}
int rec_fibo(int n)
{
if (n <= 1){
count_rec++;
return n;
}
else{
count_rec++;
return (rec_fibo(n - 1) + rec_fibo(n - 2));
}
}


````
#### 2 Recursive Method 
````java copy
public static int fibonacciRecursive(int n) {
    if (n <= 0) {
        return 0;
    } else if (n == 1 || n == 2) {
        return 1;
    }
    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}
````
![copmx](https://sem4.vercel.app/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftime-com-2.500ebcee.png&w=828&q=75)


### 3 Write user defined functions for the following sorting methods and compare their performance by time measurement with random data and Sorted data.

#### 1. Selection Sort
``` copy
#include<stdio.h>
#include<time.h>
void selection_sort(int[],int);
void main(){
int a[10000],n,i;
time_t t;
double time_taken;
clock_t start,end;
printf("Manthan Mehta:21012021048\n");
printf("Enter number of elements:");
scanf("%d",&n);
srand((unsigned)time(&t));
for(i=0;i<n;i++){
a[i]=rand()%1000;
}
start=clock();
selection_sort(a,n);
end=clock();
printf("\nSorted randomly generated elements are:");
for(i=0;i<n;i++){
printf("%d ",a[i]);
}
time_taken=(double)(end-start)/CLOCKS_PER_SEC;
printf("\nTime taken by selection sort for random unsorted array: %lf",time_taken);
for(i=0;i<n;i++){
a[i]=i+1;
}
start=clock();
selection_sort(a,n);
end=clock();
printf("\n\nSorted elements are: ");
for(i=0;i<n;i++){
printf("%d ",a[i]);
}
time_taken=(double)(end-start)/CLOCKS_PER_SEC;
printf("\nTime taken by selection sort for sorted array: %lf",time_taken);
}
void selection_sort(int a[],int n){
int i,j,min,temp;
for(i=0;i<n-1;i++){
min=i;
for(j=i+1;j<n;j++){
if(a[min]>a[j]){
min=j;
}
}
if(min!=i){
temp=a[i]; a[i]=a[min];
a[min]=temp;
}
}
}
```
#### 2. Bubble Sort
```` copy
#include<stdio.h>
#include<time.h>
void bubble_sort(int [],int);
void main()
{
int a[10000],n,i;
time_t t;
double time_taken;
clock_t start,end;
printf("Manthan Mehta:21012021048\n");
printf("Enter number of elements: ");
scanf("%d",&n);
srand((unsigned) time(&t));
for(i=0;i<n;i++)
{
a[i]=rand() % 1000;
}
start=clock();
bubble_sort(a,n);
end=clock();
printf("\nSorted randomly generated elements are: ");
for(i=0;i<n;i++)
{
printf("%d ",a[i]);
}
time_taken=(double)(end-start)/CLOCKS_PER_SEC;
printf("\nTime taken by bubble sort for random unsorted array: %lf",time_taken);
for(i=0;i<n;i++)
{
a[i]=i+1;
}
start=clock();
bubble_sort(a,n);
end=clock();
printf("\n\nSorted elements are: ");
for(i=0;i<n;i++)
{
printf("%d ",a[i]);
}
time_taken=(double)(end-start)/CLOCKS_PER_SEC;
printf("\nTime taken by bubble sort for sorted array: %lf",time_taken);
}
void bubble_sort(int a[],int n)
{int i,j,temp,flag;
for(i=0;i<n-1;i++)
{
flag=0;
for(j=0;j<n-1-i;j++)
{
if(a[j]>a[j+1])
{
temp=a[j];
a[j]=a[j+1];
a[j+1]=temp;
flag=1;
}
}
if(flag==0)
{
break;
}
}
}

````
#### 3. Insertion Sort
```` copy
#include<stdio.h>
#include<time.h>
void insertion_sort(int [],int);
void main()
{
int a[10000],n,i;
time_t t;
double time_taken;
clock_t start,end;
printf("Manthan Mehta:21012021048\n");
printf("Enter number of elements: ");
scanf("%d",&n);
srand((unsigned) time(&t));
for(i=0;i<n;i++)
{
a[i]=rand() % 1000;
}
start=clock();
insertion_sort(a,n);
end=clock();
printf("\nSorted randomly generated elements are: ");
for(i=0;i<n;i++)
{
printf("%d ",a[i]);
}
time_taken=(double)(end-start)/CLOCKS_PER_SEC;printf("\nTime taken by insertion sort for random unsorted array: %lf",time_taken);
for(i=0;i<n;i++)
{
a[i]=i+1;
}start=clock();
insertion_sort(a,n);
end=clock();
printf("\n\nSorted elements are: ");
for(i=0;i<n;i++)
{
printf("%d ",a[i]);
}
time_taken=(double)(end-start)/CLOCKS_PER_SEC;
printf("\nTime taken by insertion sort for sorted array: %lf",time_taken);
}
void insertion_sort(int a[],int n)
{
int i,j,temp;
for(i=1;i<n;i++)
{
temp=a[i];
j=i-1;
while(j>=0 && a[j]>temp)
{
a[j+1]=a[j];
j--;
}
a[j+1]=temp;
}
}
````
#### 4. Merge Sort
```` copy
#include<stdio.h>
#include<time.h>
int a[10000], b[10000];
void merge (int a[], int lb, int mid, int ub)
{
int i, j, k;
i = lb;
j = mid + 1;
k = lb;
while (i <= mid && j <= ub){
if (a[i] <= a[j]){
b[k] = a[i];
i++;
k++;
}else{
b[k] = a[j];
j++;
k++;
}
}
if (i
> mid){
while (j <= ub){
b[k]
= a[j];
j++;
k++;
}
}else{
while (i <= mid){
b[k]
= a[i];
i++;
k++;
}}
for (i
= lb;
i <= ub; i++){
a[i]
= b[i];
}
}
void merge_sort (int a[], int lb, int ub){
int mid;
if (lb
< ub)
{
mid
= (lb
+ ub)
/ 2;
merge_sort (a, lb, mid);
merge_sort (a, mid
+ 1, ub);
merge (a, lb, mid, ub);
}
}
void main (){
int n, i, j;
time_t t;
double time_taken;
clock_t start, end;
printf ("Manthan Mehta: 21012021048\n");
printf ("Enter number of elements: ");
scanf ("%d", &n);
srand ((unsigned) time (&t));
for (i
= 0;
i
< n; i++){
a[i]
= rand ()
% 1000;
}
start
= clock ();
merge_sort (a, 0,
n
- 1);
end
= clock ();
printf ("\nSorted randomly generated elements are: ");
for (i
= 0;
i
< n; i++){
printf ("%d ", a[i]);
}
time_taken = (double) (end - start) / CLOCKS_PER_SEC;
printf ("\nTime taken by merge sort for random unsorted array: %lf",time_taken);
for (i = 0; i < n; i++){
a[i] = i + 1;
}
start = clock ();
merge_sort (a, 0, n - 1);
end = clock ();
printf ("\n\nSorted elements are: ");
for (i = 0; i < n; i++){
printf ("%d ", a[i]);
}
time_taken = (double) (end - start) / CLOCKS_PER_SEC;
printf ("\nTime taken by merge sort for sorted array: %lf", time_taken);
}

````
#### 5. Quick Sort
```` copy
#include<stdio.h>
#include<time.h>
void quick_sort (int a[], int p, int q) {
if(p==q){
return a;
}else{
if(p<q){
int m=partition(a,p,q);
quick_sort(a,p,m-1);
quick_sort(a,m+1,q);
}
}
}
int partition(int a[],int p,int q){
int i,j,x;
x=a[p];
i=p;
for(j=p+1;j<=q;j++){
if(a[j]<=x){
i++;
int temp=a[i];
a[i]=a[j];
a[j]=temp;
}
}
int t=a[i];
a[i]=a[p];
a[p]=t;
return i;
}
int main () {
int a[10000], i, n;
time_t t;
double time_taken;
clock_t start, end;
printf ("Manthan Mehta: 21012021048\n");
printf ("Enter number of elements: ");
scanf ("%d", &n);
srand ((unsigned) time (&t));
for (i = 0; i < n; i++){
a[i] = rand () % 1000;
}
start = clock ();
quick_sort (a, 0, n - 1);
end = clock ();
printf ("\nSorted randomly generated elements are: ");
for (i = 0; i < n; i++){
printf ("%d ", a[i]);
}
time_taken = (double) (end - start) / CLOCKS_PER_SEC;
printf ("\nTime taken by quick sort for random unsorted array: %lf",time_taken);
for (i = 0; i < n; i++){
a[i] = i + 1;
}
start = clock ();
quick_sort (a, 0, n - 1);
end = clock ();
printf ("\n\nSorted elements are: ");
for(i=0;i<n;i++){
printf("%d ",a[i]);
}
time_taken=(double)(end-start)/CLOCKS_PER_SEC;
printf("\nTime taken by quick sort for sorted array: %lf",time_taken);
return 0;
}

````
![comop](https://sem4.vercel.app/images/comp-3.png)

### 5 Implement a function of sequential search and count the steps executed by function on various inputs for best case and worst case. Also write complexity in each case and draw a comparative chart.
````java copy
#include <stdio.h>
#include <stdlib.h>
void countingSort(int arr[], int n) {
 int max_val = arr[0];
 for(int i = 1; i < n; i++) {
 if(arr[i] > max_val) {
 max_val = arr[i];
 }
 }
 int size = max_val + 1;
 int count[size];
 for(int i = 0; i < size; i++) {
 count[i] = 0;
 }
 for(int i = 0; i < n; i++) {
 count[arr[i]]++;
 }
 int sorted[n];
 int j = 0;
 for(int i = 0; i <= max_val; i++) {
 while(count[i] > 0) {
 sorted[j] = i;
 count[i]--;
 j++;
 }
 }
  for(int i = 0; i < n; i++) {
 arr[i] = sorted[i];
 }
}
void printArr(int arr[], int n) {
 printf("[");
 for(int i = 0; i < n; i++) {
 printf("%d ", arr[i]);
 }
 printf("]");
}
int main() {
 int size;
 printf("Rathod Yuvraj - 21012011129");
 printf("Enter the size of the array: ");
 scanf("%d", &size);
 int arr[size];
 printf("Enter %d integers:\n", size);
 for(int i = 0; i < size; i++) {
 scanf("%d", &arr[i]);
 }
 printf("Data before sorting: ");
 printArr(arr, size);
 countingSort(arr, size); 
  printf("\nData after sorting: ");
 printArr(arr, size);
 return 0;
} 

````
![comp5](https://sem4.vercel.app/images/comp5.png)

### 6 Implement program for randomized version of quick sort and compare its performance with normal version of quick sort using steps count on various number of inputs.
#### 1 randomized version for quickSort
````java copy
  #include <stdio.h>
void knapsack(int n, float weight[], float profit[], float capacity)
{
 float x[20], tp = 0;
 int i, j, k;
 k = capacity;
 for (i = 0; i < n; i++){
 x[i] = 0.0;
 }
 printf("\nthe result is:- ");
 for (i = 0; i < n; i++)
 {
 if (weight[i] > k)
 break;
 else
 {
 x[i] = 1.0;
 int p = profit[i];
 tp = tp + profit[i];
 k = k - weight[i];
 printf("%f * %d +\t ", x[i],p);
 }
 }
 if (i < n)
 x[i] = k / weight[i];
 tp = tp + (x[i] * profit[i]);
 int p = profit[i];
 printf("%f * %d\t ", x[i],p);
 printf("\nmaximum profit is: %f", tp);
}
int main()
{ 
  printf("Rathod Yuvraj - 21012011129\n");

 int num, i, j;
 float weight[20], profit[20], capacity;
 float ratio[20], temp;
 printf("\nenter the no of object:-");
 scanf("%d", &num);
 printf("\nenter the weight and profit of each object:-\n ");
 for (i = 0; i < num; i++)
 {
 printf("weight[%d] :",i+1);
 scanf("%f", &weight[i]);
 printf("profit[%d] :",i+1);
 scanf("%f", &profit[i]);
 }
 printf("\nEnter the capacityacity of knapsack:- ");
 scanf("%f", &capacity);
 for (i = 0; i < num; i++)
 {
 ratio[i] = profit[i] / weight[i];
 printf("profit / weight ratio for object %d is %f \n",i+1,ratio[i]);
 }
 for (i = 0; i < num; i++)
 {
 for (j = i + 1; j < num; j++)
 {
 if (ratio[i] < ratio[j])
 {
 temp = ratio[j];
 ratio[j] = ratio[i];
 ratio[i] = temp;
 temp = weight[j];
 weight[j] = weight[i];
 weight[i] = temp;
 temp = profit[j];
 profit[j] = profit[i];
 profit[i] = temp; 
 }
 }
 }
 knapsack(num, weight, profit, capacity);
 return (0);
}

````
![comp6](https://sem4.vercel.app/images/comp6.png)


### 7 Implement program of Counting Sort
````java copy
 #include <stdio.h>
#include <stdlib.h>
#define MAX_COINS 50
#define MAX_COST 1000
void sort(int array[], int size) {
 for (int step = 0; step < size - 1; ++step) {
 for (int i = 0; i < size - step - 1; ++i) {
 if (array[i] > array[i + 1]) {
 int temp = array[i];
 array[i] = array[i + 1];
 array[i + 1] = temp;
 }
 }
 }
}
void findMin(int coins[], int n, int cost) {
 int coinList[MAX_COINS] = { 0 };
 int i, k = 0;
 for (i = n - 1; i >= 0; i--) {
 while (cost >= coins[i]) {
 cost -= coins[i];
 coinList[k++] = coins[i];
 }
 }
printf("\nMinimum number of coins required to make the given amount: %d\n", k);
 printf("The coins used to make the amount are: ");
 for (i = 0; i < k; i++) { 
 printf("%d ", coinList[i]);
 }
 printf("\n");
 return;
}
int main() {
 int n, cost, coins[MAX_COINS];
 printf("rathod Yuvraj - 21012011129\n");
 printf("Enter the number of available type of coins : ");
 scanf("%d", &n);
 printf("Enter the value of each coin: ");
 for (int i = 0; i < n; i++) {
 scanf("%d", &coins[i]);
 }
 sort(coins,n);
printf("Enter the cost for which you want to find the minimum number of coins required: ");
 scanf("%d", &cost);
 findMin(coins, n, cost);
 return 0;
} 

````

### 8 Implement Program for fractional knapsack using Greedy design technique
````java copy
#include <stdio.h>
#include <stdlib.h>
int main()
{
 int m, n, i, j;
 printf("Rathod Yuvraj - 21012011129 \n");
 printf("Enter the amount of which you want change: ");
 scanf("%d", &m);
 printf("Enter the number of determinants: ");
 scanf("%d", &n);
 int c[n + 1][m + 1], dc[n + 1];
 printf("Enter the determinants: ");
 dc[0] = 0;
 for (i = 1; i < n + 1; i++)
 scanf("%d", &dc[i]);
 for (i = 0; i < n + 1; i++)
 {
 for (j = 0; j <= m; j++)
 c[i][j] = 0;
 }
 for (i = 0; i < n + 1; i++)
 c[i][0] = 0;
 for (i = 0; i < m + 1; i++)
 {
 c[0][i] = i;
 }
 for (i = 1; i < n + 1; i++)
 {
 for (j = 1; j < m + 1; j++)
 {
 if (dc[1] > c[0][j])
 c[i][j] = 0;
 else if (dc[i] <= j)
 {
 if ((c[i][j - dc[i]] + 1) < c[i - 1][j])
 c[i][j] = (c[i][j - dc[i]] + 1);
 else
 c[i][j] = c[i - 1][j];
 }
 else
 c[i][j] = c[i - 1][j];
 }
 }
 printf("\nThe change you get is: ");
 i = n;
 j = m;
 while (i != 1)
 {
 if (c[i][j] == c[i - 1][j])
 i = i - 1;
 else
 {
 j = j - dc[i];
 printf(" %d ", dc[i]);
 }
 } 
 printf("\n\n");
 return 0;
} 

````

### 9 Implement Program for ‚ÄúMaking Change‚Äù using Greedy design technique
````java copy
#include <stdio.h>
int max(int a, int b)
{
 return (a > b) ? a : b;
}
int knapSack(int W, int wt[], int val[], int n)
{
 int i, w;
 int K[n + 1][W + 1];
 for (i = 0; i <= n; i++)
 {
 for (w = 0; w <= W; w++)
 {
 if (i == 0 || w == 0)
 K[i][w] = 0;
 else if (wt[i - 1] <= w)
 K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]);
 else
 K[i][w] = K[i - 1][w];
 }
 }
 return K[n][W];
}
int main()
{
 int n, W;
 printf("rathod Yuvraj - 21012011129 \n");
 printf("Enter the number of items: ");
 scanf("%d", &n);
 int val[n], wt[n]; 
 printf("Enter the values of the items: ");
 for (int i = 0; i < n; i++)
 scanf("%d", &val[i]);
 printf("Enter the weights of the items: ");
 for (int i = 0; i < n; i++)
 scanf("%d", &wt[i]);
 printf("Enter the maximum capacity of the knapsack: ");
 scanf("%d", &W);
 int result = knapSack(W, wt, val, n);
 printf("The maximum profit is:%d\n", result);
 return 0;
} 

````
### 10 Implement Program for ‚ÄúMaking Change‚Äù using Dynamic Programming
````java copy
#include <stdio.h>
#include <math.h>
#include<stdlib.h>
int board[20], count;
void print(int n) {
 int i, j;
 printf("\nSolution %d:\n\n", ++count);
 for (i = 1; i <= n; ++i) {
 printf("\t%d", i);
 }
 for (i = 1; i <= n; ++i) {
 printf("\n%d", i);
 for (j = 1; j <= n; ++j) { // for nxn board
 if (board[i] == j)
 printf("\tQ"); //queen at i,j position
 else
 printf("\t-"); //empty slot 
  }
 }
}
int place(int row, int column) {
 int i;
 for (i = 1; i <= row - 1; ++i) {
 // checking column and diagonal conflicts
 if (board[i] == column)
 return 0; 
  else if (abs(board[i] - column) == abs(i - row))
 return 0;
 }
 return 1; // no conflicts
}
void queen(int row, int n) {
 int column;
 for (column = 1; column <= n; ++column) {
 if (place(row, column)) {
 board[row] = column; // no conflicts so place queen
 if (row == n) // dead end
 print(n); // printing the board configuration
 else // try queen with next position
 queen(row + 1, n);
 }
 }
}
int main() {
 int n;
 printf("Rathod Yuvraj - 21012011129\n");
 printf(" - N Queens Problem Using Backtracking -\n");
 printf("Enter number of Queens: ");
 scanf("%d", &n);
 if (n < 4) {
 printf("Solution does not exist for n < 4\n");
 return 0;
 }
 queen(1, n);
 if (count == 0) {
 printf("Solution does not exist\n"); 
  }
 return 0;
} 


````